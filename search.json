[{"title":"Javascript数组常用的操作方法","url":"/2022/01/15/Javascript%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/","content":"数组去重\n数组中的元素是原始数据类型\nconst numbers = [1, 2, 3, 1]console.log([...new Set(numbers)])console.log(Array.from(new Set(numbers))// 输出结果：[1, 2, 3]\n数组中的元素是对象类型\nconst todos = [  &#123; id: 1, title: &#x27;Vue&#x27; &#125;,  &#123; id: 2, title: &#x27;React&#x27; &#125;,  &#123; id: 3, title: &#x27;Angular&#x27; &#125;,  &#123; id: 1, title: &#x27;Vue&#x27; &#125;,]console.log(arrayUnique(todos, &#x27;id&#x27;))// 输出结果:[  &#123; id: 1, title: &#x27;Vue&#x27; &#125;,  &#123; id: 2, title: &#x27;React&#x27; &#125;,  &#123; id: 3, title: &#x27;Angular&#x27; &#125;]function arrayUnique(arr, on)&#123;  const ret = &#123;&#125;  arr.forEach(item =&gt; &#123;    if ( !ret[item[on]] )&#123;      ret[item[on]] = item    &#125;  &#125;)  return Object.values(ret)&#125;\n数组的排序\nconst d = [2, 10, 1, -1]const arr = [  &#123; id: 1, title: &#x27;Learn Vue&#x27; &#125;,   &#123; id: 3, title: &#x27;Learn React&#x27; &#125;,   &#123; id: 2, title: &#x27;Learn Angular&#x27; &#125;, ]d.sort(buildSorter())arr.sort(buildSorter(&#x27;id&#x27;)) // 升序// arr.sort(buildSorter(&#x27;id&#x27;， &#x27;DESC&#x27;)) // 降序console.log(d)console.log(arr)// 输出结果：[-1, 1, 2, 10][  &#123; id: 1, title: &#x27;Learn Vue&#x27; &#125;,   &#123; id: 2, title: &#x27;Learn Angular&#x27; &#125;,   &#123; id: 3, title: &#x27;Learn React&#x27; &#125;, ]function buildSorter(on, SORT = &#x27;ASC&#x27;)&#123;  SORT = SORT.toUpperCase()  const sign = SORT === &#x27;ASC&#x27; ? 1 : -1  if ( on ) &#123;    return (a, b) =&gt; sign * (a[on] - b[on])  &#125;else &#123;    return (a, b) =&gt; sign * (a - b)  &#125;&#125;\n数组列(column)\nconst todos = [  &#123; id: 1, title: &#x27;Vue&#x27; &#125;,  &#123; id: 2, title: &#x27;React&#x27; &#125;,  &#123; id: 3, title: &#x27;Angular&#x27; &#125;,]console.log(arrayColumn(todos, &#x27;id&#x27;))// 输出结果:[1, 2, 3]function arrayColumn(arr, on)&#123;  return arr.map(item =&gt; item[on])&#125;\n数组的交集, 差集, 并集, 补集\nconst d1 = [1, 2, 3]const d2 = [2, 3, 4]console.log(arrayIntersect(d1, d2)) // [2, 3]console.log(arrayMinus(d1, d2)) // [1]console.log(arrayMinus(d2, d1)) // [4]console.log(arrayUnion(d1, d2)) // [1, 2, 3, 4]console.log(arrayComplement(d1, d2)) // [1, 4]// 交集function arrayIntersect(a, b)&#123;  return a.filter(val =&gt; b.indexOf(val) !== -1)&#125;// 差集function arrayMinus(a, b)&#123;  return a.filter(val =&gt; b.indexOf(val) === -1)&#125;// 并集function arrayUnion(a, b)&#123;  return a.concat(arrayMinus(b, a))&#125;// 补集function arrayComplement(a, b)&#123;  return arrayMinus(a, b).concat(arrayMinus(b, a))&#125;","categories":["FrontEnd"],"tags":["JavaScript"]},{"title":"tree命令的简单使用","url":"/2022/01/20/tree%E5%91%BD%E4%BB%A4%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","content":"前言\n想着项目完成的差不多了，我是不是应该把REAMME.md好好写一下。于是，带着这个想法，不多说，直接开干。\nFirst, Installing\nSecond: Example\nThird: Project Structure。那些github上面漂亮的项目结构怎么生成的？\nMore…\n安装\nsudo apt install tree\ntree命令\ntree --help\nusage: tree [-acdfghilnpqrstuvxACDFJQNSUX] [-H baseHREF] [-T title ]\t[-L level [-R]] [-P pattern] [-I pattern] [-o filename] [--version]\t[--help] [--inodes] [--device] [--noreport] [--nolinks] [--dirsfirst]\t[--charset charset] [--filelimit[=]#] [--si] [--timefmt[=]&lt;f&gt;]\t[--sort[=]&lt;name&gt;] [--matchdirs] [--ignore-case] [--fromfile] [--]\t[&lt;directory list&gt;]  ------- Listing options -------  -a            All files are listed.  -d            List directories only.  -l            Follow symbolic links like directories.  -f            Print the full path prefix for each file.  -x            Stay on current filesystem only.  -L level      Descend only level directories deep.  -R            Rerun tree when max dir level reached.  -P pattern    List only those files that match the pattern given.  -I pattern    Do not list files that match the given pattern.  --ignore-case Ignore case when pattern matching.  --matchdirs   Include directory names in -P pattern matching.  --noreport    Turn off file/directory count at end of tree listing.  --charset X   Use charset X for terminal/HTML and indentation line output.  --filelimit # Do not descend dirs with more than # files in them.  --timefmt &lt;f&gt; Print and format time according to the format &lt;f&gt;.  -o filename   Output to file instead of stdout.  ------- File options -------  -q            Print non-printable characters as &#x27;?&#x27;.  -N            Print non-printable characters as is.  -Q            Quote filenames with double quotes.  -p            Print the protections for each file.  -u            Displays file owner or UID number.  -g            Displays file group owner or GID number.  -s            Print the size in bytes of each file.  -h            Print the size in a more human readable way.  --si          Like -h, but use in SI units (powers of 1000).  -D            Print the date of last modification or (-c) status change.  -F            Appends &#x27;/&#x27;, &#x27;=&#x27;, &#x27;*&#x27;, &#x27;@&#x27;, &#x27;|&#x27; or &#x27;&gt;&#x27; as per ls -F.  --inodes      Print inode number of each file.  --device      Print device ID number to which each file belongs.  ------- Sorting options -------  -v            Sort files alphanumerically by version.  -t            Sort files by last modification time.  -c            Sort files by last status change time.  -U            Leave files unsorted.  -r            Reverse the order of the sort.  --dirsfirst   List directories before files (-U disables).  --sort X      Select sort: name,version,size,mtime,ctime.  ------- Graphics options -------  -i            Don&#x27;t print indentation lines.  -A            Print ANSI lines graphic indentation lines.  -S            Print with CP437 (console) graphics indentation lines.  -n            Turn colorization off always (-C overrides).  -C            Turn colorization on always.  ------- XML/HTML/JSON options -------  -X            Prints out an XML representation of the tree.  -J            Prints out an JSON representation of the tree.  -H baseHREF   Prints out HTML format with baseHREF as top directory.  -T string     Replace the default HTML title and H1 header with string.  --nolinks     Turn off hyperlinks in HTML output.  ------- Input options -------  --fromfile    Reads paths from files (.=stdin)  ------- Miscellaneous options -------  --version     Print version and exit.  --help        Print usage and this help message and exit.  --            Options processing terminator.\ntree常用命令\n\n\n\n命令\n描述\n\n\n\n\n-a\n显示所有文件\n\n\n-d\n仅显示目录\n\n\n-L level\n列出的目录的最大深度\n\n\n-f\n打印每个文件的完整路径前缀\n\n\n-P pattern\n列出匹配给定模式的文件\n\n\n-I pattern\n不列出匹配给定模式的文件\n\n\n-o filename\n输出到文件，而不是标准输出\n\n\n-N\n按原样打印不可打印的字符(比如 中文)\n\n\n-J\n打印输出树的JSON表示\n\n\n\n举个栗子\n# 仅列出目录，最大目录深度为3，忽略node_modules和dist目录tree -d -L 3 -I &#x27;node_modules|dist&#x27;\n最后\n# 将列出的结果追加到 README.md 文件 ( 记得给内容加上```content```表示代码块 )# 然后加上注释，就可以得到好看的项目目录结构tree -I &#x27;node_modules|dist|.git&#x27; -L 3 -a &gt;&gt; README.md","categories":["Linux"],"tags":["tree"]},{"title":"2021年终总结","url":"/2022/01/25/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/","content":"工作\nPHPer =&gt; FND\n🚀🚀🚀\n健康\n…\n\n多喝水 (每天大于4L)\n不熬夜 (晚上12点前睡觉)\n不喝碳酸饮料，不吃麻辣\n适当运动\n\n进阶 2022\nflag\n\n[ ] 拥有扎实的JavaScript基础\n[ ] 书籍\n[ ] underscore 源码过一遍\n[ ] 熟悉Vue原理，Vue源码过一遍\n[ ] 熟悉 Vue3 + Vite + TS 技术栈\n[ ] 熟悉小程序开发\n[ ] 熟悉Node.js技术栈\n[ ] LeetCode刷题 50+\n[ ] 具备基本的医学常识\n[ ] 多读科普，社会人文书籍\n\n书籍\n\n《JavaScript语言精粹》\n《你不知道的JavaScript(上，中，下)》\n《JavaScript高级程序设计》\n《Vue.js深入浅出》\n《NodeJS深入浅出》\n《图解HTTP》\n\n","tags":["年终总结"]},{"title":"JavaScript语言精粹-总结","url":"/2022/02/01/JavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9-%E6%80%BB%E7%BB%93/","content":"因为这本书出版的时候ES6还没有问世，所以书中不涉及ES6的知识点。因此下面的总结不会使用ES6的语法。\n数据类型\n共8种数据类型\n基本类型\n\nNumber\nString\nBoolean\nnull\nundefined\nSymbol\nBigInt\n\n引用类型\n\nObject(对象)\n\n检测数据类型\njavascript 提供了 typeof 结构用来检测数据的类型。\n但是对于引用类型，函数则会返回’function’，其他的引用类型和null都会得到’object’。\nconsole.log(typeof Math.floor) // &#x27;function&#x27; console.log(typeof null)       // &#x27;object&#x27;console.log(typeof [])         // &#x27;object&#x27;console.log(typeof &#123;&#125;)         // &#x27;object&#x27;\n可以看出，typeof 有诸多限制，无法区分 null 以及除 function 之外的其他引用类型。\n既然 typeof 走不通，那就使用 javascript 提供的另一种检测方法:\nObject.prototype.toString\n它可以很好的检测出所有的数据类型\nvar protoToString = Object.prototype.toStringconsole.log(protoToString.call(1))         // [object Number]console.log(protoToString.call(&#x27;1&#x27;))       // [object String]console.log(protoToString.call(undefined)) // [object Undefined]console.log(protoToString.call(null))      // [object Null]console.log(protoToString.call([]))        // [object Array]console.log(protoToString.call(&#123;&#125;))        // [object Object]console.log(protoToString.call(Math.floor)) // [object Function]\n对象(Object)\nNote that: 对象通过引用来传递，他们永远不会被复制\n对象字面量创建对象:\nvar obj = &#123;  name: &#x27;w2xi&#x27;,  age: 26,  &#x27;profile-info&#x27;: &#123;    phone: &#x27;12343&#x27;,    address: &#x27;ChangSha.China&#x27;,  &#125;,  sayHello: function()&#123;    console.log(&#x27;hi&#x27;)  &#125;&#125;\n检索属性。如果该对象没有相应的属性，则会沿着原型链查找，找到则返回相应的值，否则为undefined。\nobj.nameobj[&#x27;profile-info&#x27;]\n赋值。只会在该对象上操作，不会影响原型链。\nobj.name = &#x27;wiki&#x27;obj[&#x27;profile-info&#x27;][&#x27;address&#x27;] = &#x27;ShangHai.China&#x27;\n删除对象的属性。只会删除该对象上的属性，不会影响原型链上的属性。\ndelete obj.age\n对象枚举。\nfor ( var key in obj )&#123;  console.log(key, obj[key])&#125;\n判断对象上是否有某个属性\nObject.prototype.hasOwnProperty(&#x27;prop&#x27;) // 目标对象上有这个属性，则返回true，否则false&#x27;prop&#x27; in Object // 属性在原型链上，则返回true，否则falseobj.hasOwnProperty(&#x27;name&#x27;) // trueobj.hasOwnProperty(&#x27;money&#x27;) // false\n判断对象上没有constructor属性，但是原型链上有。\n!obj.hasOwnProperty(&#x27;constructor&#x27;) &amp;&amp; &#x27;constructor&#x27; in obj // true\n函数(Function)\n函数是 javascript 的一等公民。\n函数的组成: function关键字，函数名(标识符)，紧跟函数名的参数列表以及由花括号({})扩起来的函数体。\n创建函数:\n\n普通函数\n\nfunction sum(a ,b)&#123;  return a + b&#125;\n\n通过字面量的方式\n\nvar sum = function(a, b)&#123;  return a + b&#125;\n\n构造函数(首字母大写，默认约定)，在继承部分会详细介绍\n\nfunction Foo()&#123;&#125;\n调用:\nsum(1, 2) // 3\nIIFE(Immediately Invoked Function Expression)立即调用的函数表达式:\n(function()&#123;  // todo something.&#125;())\nArguments\narguments 是函数内部特有的一个变量，保存了调用函数时传递的所有参数。\n描述:\narguments 是一个 类数组(array-like) 对象。\n它有一个length属性并且属性从下标0开始，但是它没有数组内置的一些方法，像 forEach(), map()。\n将类数组转换为数组:\nfunction foo()&#123;  var args = Array.prototype.slice.call(arguments)  // Using an array literal is shorter than above but allocates an empty array  var args = [].slice.call(arguments)  console.log(args)&#125;foo(1, 2, 3) // [1, 2, 3]\n求和，不限定参数个数:\nfunction sum()&#123;  var total = 0  for ( var i = 0; i &lt; arguments.length; i++ )&#123;    total += arguments[i]  &#125;  return total&#125;sum(1, 2， 3, 4) // 10\nScope\n在javascript中，用var声明的变量是函数作用域的。\n是的，不是块级作用域，这一特性非常糟糕，可能不小心就会导致一些问题。\n外部函数的变量对内部函数来说都是可见的；内部函数的变量对外部来说是不可见的。\nvar color = &#x27;red&#x27;function outer()&#123;  var outerName = &#x27;outer&#x27;  function inner()&#123;    var innerName = &#x27;inner&#x27;    // color, outerName is seen  &#125;  // innerName is not seen  inner()&#125;// outerName, innerName is not seenouter()\n变量提升\n用 var 声明的变量会被提升到该变量所在词法环境(lexical environment)的顶部。\n例子:\nfunction test()&#123;  console.log(a) // undefined  var a = &#x27;test&#x27;&#125;test()\n闭包(Closure)\n让我们来看一个例子，很简单，就是一个计数器:\nvar counter = (function()&#123;  var count = 0  return &#123;    add: function(inc)&#123;      return count += typeof inc === &#x27;number&#x27; ? inc : 1    &#125;,    getValue: function()&#123;      return count    &#125;  &#125;&#125;())counter.add() // 1counter.add() // 2console.log(counter.getValue()) // 2\n这里使用了iife。函数里定义了一个count变量，\n该变量对 add 和 getValue 方法总是可用的，但函数的作用域使用它对其他的程序来说是不可见的。\n该函数将返回一个包含两个方法的对象，并且这些方法继续享有访问count变量的特权。\n像这样，函数可以访问它被创建时所处的上下文环境。这被成为闭包。\n柯里化(Currying)\n柯里化\n柯里化是一种函数的转换，它是指将一个函数从可调用的 f(a, b, c) 转换为可调用的 f(a)(b)©。\n柯里化不会调用函数，它只是对函数进行转换。\n举个例子:\n// 实现如这种形式的函数调用sum(1, 2, 3) // 6sum(1, 2)(3) // 6sum(1)(2)(3) // 6\nvar protoSlice = Array.prototype.slicefunction f(a, b ,c)&#123;  return a + b + c&#125;function curry(func)&#123;  return function curried()&#123;    var args = protoSlice.call(arguments)    if ( args.length &gt;= func.length )&#123;      return func.apply(this, args)    &#125;else &#123;      return function()&#123;         return curried.apply(this, args.concat(protoSlice.call(arguments)))      &#125;    &#125;  &#125;&#125;var sum = curry(f)sum(1, 2, 3) // 6sum(1, 2)(3) // 6sum(1)(2)(3) // 6\nInheritance ( extends )\n就以我所了解的PHP(后端编程语言)来说，它是一门面向对象的编程语言(OOP)，是一个类继承另一个类。比如:\nclass People &#123;  public $name;  public $age;  public $height;  public $weight;  public function constructor($name, $age, $height, $weight) &#123;    $this-&gt;name = $name;    $this-&gt;age = $age;    $this-&gt;height = $height;    $this-&gt;weight = $weight;  &#125;  public function say()&#123;    echo &quot;&#123;$this-&gt;name&#125; say...&quot;;  &#125;  public function eat()&#123;    echo &quot;&#123;$this-&gt;name&#125; eat...&quot;;  &#125;&#125;// Children 类也可以定义自己的属性和方法class Children extends People &#123;&#125;\n我们定义了 People 类，它有 姓名，年纪，身高，体重4个公共成员属性以及说话，吃饭2个公共方法；再定义一个继承People 的 Children 类，这样 Children 类就有了 父类(People) 的所有属性和方法。\n$xiaoming = new Children(&#x27;xaioming&#x27;, 5, 100, 30);echo $xiaoming-&gt;name; // &#x27;xiaoming&#x27;echo $xiaoming-&gt;say();// &#x27;xiaoming say...&#x27;echo $xiaoming-&gt;eat();// &#x27;xiaoming eat...&#x27;\n但是在 JavaScript 中，情况似乎有点不一样，它并不像PHP那样是基于类的继承。\nJavaScript 是基于 原型 的继承，即对象继承自另一个对象，而且他还不是直接的继承，\n而是引入了一个多余的间接层: 通过构造器函数产生对象。\n构造函数\n构造函数也是一个函数，为了让它区别于普通函数，按照约定，构造函数的首字母需要大写。\n当一个函数对象被创建时，Function 构造器产生的函数对象会运行类似这样的一些代码:\nthis.prototype = &#123;constructor: this&#125;\n新函数对象会被赋予一个 prototype 属性，它的值是一个包含 constructor 属性且属性值为该新函数的对象。\n这个 prototype 对象是存放继承特征的地方。\n我们可以定义一个构造器并扩充它的原型:\nfunction Person(name)&#123;  this.name = name&#125;Person.prototype.getName = function()&#123;  return this.name&#125;Person.prototype.says = function()&#123;  return this.saying || &#x27;&#x27;&#125;\n现在我们可以构造一个实例:\nvar xiaoming = new Person(&#x27;xiaoming&#x27;)xiaoming.getName();                     // &#x27;xiaoming&#x27;xiaoming instanceof Person              // true// 实例对象的[[prototype]]属性指向 构造函数的原型对象xiaoming.__proto__ === Person.prototype // true// 构造函数原型对象上的 constructor 属性指向构造函数本身Person.prototype.constructor === Person // true\n更多的继承相关的细节到时候会专门写一篇JavaScript专题来描述(写好后会放一个超链接)。\n让 new 运算符像一个方法一样被执行\n(这里到时候可以开一个专题)\n让我们来模拟 new 运算符的执行过程:\n\n创建一个对象\n将新创建的对象的[[prototype]]特性指向构造函数的原型对象\n调用构造函数，将构造函数中的this指向新创建的对象并传入对应的参数\n如果调用构造函数的返回结果是一个对象，则返回该对象；否则返回新创建的对象\n\nfunction mockNew()&#123;  var constructFunc = arguments[0]  var args = Array.prototype.slice.call(arguments, 1)  var target = Object.create(constructFunc.prototype)  var ret = constructFunc.apply(target, args)  return (typeof ret === &#x27;object&#x27; &amp;&amp; ret) : target&#125;// 验证:function Person(name, age)&#123;  this.name = name  this.age = age&#125;var xiaoming = mockNew(Person, &#x27;xiaoming&#x27;, 21)console.log(xiaoming)                               // Person &#123;name: &quot;xiaoming&quot;, age: 21&#125;console.log(xiaoming.__proto === Person.prototype)  // true\n数组(Array)\n数组是一段线性分配的内存，它通过整形计算偏移并访问其中的元素。数组是一种性能出色的数据结构。不幸的是，JavaScript没有像此类数组一样的数据结构。\n作为代替，JavaScript 提供了一种拥有类数组(array-like)特性的对象。它把数组的下标转变成字符串，用其作为属性。\n它明显地比一个真正的数组慢，但它使用起来更方便。它的属性的检索和更新的方式与对象一模一样。\n数组字面量\n数组的第一个值将获得属性名为’0’, 第二个值将获得属性名’1’，依此类推。\nvar empty = [];var months = [  &#x27;January&#x27;, &#x27;February&#x27;, &#x27;March&#x27;, &#x27;April&#x27;, &#x27;May&#x27;, &#x27;June&#x27;,  &#x27;July&#x27;, &#x27;August&#x27;, &#x27;September&#x27;, &#x27;October&#x27;, &#x27;November&#x27;, &#x27;December&#x27;,];empty[0];     // undefinedmonths[0];    // &#x27;January&#x27;empty.length; // 0months.length // 12\n对象字面量:\nvar monthsObject = &#123;  0: &#x27;January&#x27;, 1: &#x27;February&#x27;, 3: &#x27;March&#x27;, 4: &#x27;April&#x27;, 5: &#x27;May&#x27;, 6: &#x27;June&#x27;,  7: &#x27;July&#x27;, 8: &#x27;August&#x27;, 9: &#x27;September&#x27;, 10: &#x27;October&#x27;, 11: &#x27;November&#x27;, 12: &#x27;December&#x27;,&#125;\nmonths 和 monthsObject 产生的结果类似。它们都是包含10个属性的对象，并且那些属性刚好有相同的名字和值。\n但是它们也有一些显著的不同，months 继承自 Array.prototype，而 monthsObject 继承自 Object.prototype，\n所以 months 继承了大量有用的方法。同时，months 还有一个 length 属性，而 monthsObject 则没有。\n","categories":["FrontEnd"],"tags":["JavaScript"]},{"title":"JavaScript专题之类型判断","url":"/2022/02/02/JavaScript%E4%B8%93%E9%A2%98%E4%B9%8B%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/","content":"前言\n类型判断，在我们平时的工作中会经常使用到。比如，判断给定值是否是数字，字符串，布尔值和数组等类型。\ntypeof\ntypeof 应该是我们最常用地用于判断数据类型的一种方式了。\nExample:\ntypeof 1    // &#x27;number&#x27;typeof true // &#x27;boolean&#x27;\ntypeof 介绍:\n\ntypeof 操作符返回一个字符串，表示未经计算的操作数的类型。\n\n最新的 ECMAScript 标准定义了8种数据类型:\n\n7种基本数据类型\n\nNumber\nString\nBoolean\nnull\nundefined\nSymbol\nBigInt\n\n\n引用类型\n\n对这8种数据类型分别使用 typeof:\ntypeof 1            // &#x27;number&#x27;typeof &#x27;a&#x27;          // &#x27;string&#x27;typeof true         // &#x27;boolean&#x27;typeof null         // &#x27;object&#x27;typeof undefined    // &#x27;undefined&#x27;typeof Symbol(&#x27;s&#x27;)  // &#x27;symbol&#x27;typeof BigInt(2)    // &#x27;bigint&#x27;typeof [1]          // &#x27;object&#x27;\n可以看到，得到的结果与它们的类型并非完全一一对应。\nnull 返回了 ‘object’，而非我们期望的 ‘null’；[1] 返回了 ‘object’，而非 ‘array’。\n在 javascript 中，可以说一切皆对象。数组是对象，函数是对象，对象是对象，哈哈，但是 typeof 却可以检测出函数的类型:\ntypeof function()&#123;&#125; // &#x27;function&#x27;\n现在我们知道了，typeof 可以检测出: Number, String, Boolean, undefined, Symbol, BigInt, Function 类型。\n但是，对于 Array, Object, Arguments 等对象似乎无能为力。\ntypeof []                             // &#x27;object&#x27;typeof &#123;&#125;                             // &#x27;object&#x27;typeof function()&#123;return arguments&#125;   // &#x27;object&#x27;\n难道我们真的没有办法检测出它们的真实类型吗？\n我想我们还是有办法的。\nObject.prototype.toString\ntoString()方法返回一个表示该对象的字符串，格式: ‘[object type]’，type 表示对象的类型\n来自MDN:\n\n为了每个对象都能通过 Object.prototype.toString() 的检测，需要以 Function.prototype.call() 或者 Function.prototype.apply() 的形式来调用，传递要检查的对象作为第一个参数，称为 thisArg。\n\n看个例子:\nconst protoToString = Object.prototype.toStringprotoToString.call(1)                   // &#x27;[object Number]&#x27;protoToString.call(&#x27;a&#x27;)                 // &#x27;[object String]&#x27;protoToString.call(true)                // &#x27;[object Boolean]&#x27;protoToString.call(null)                // &#x27;[object Null]&#x27;protoToString.call(undefined)           // &#x27;[object Undefined]&#x27;protoToString.call(Symbol(&#x27;s&#x27;))         // &#x27;[object Symbol]&#x27;protoToString.call(BigInt(2))           // &#x27;[object BigInt]&#x27;protoToString.call([])                  // &#x27;[object Array]&#x27;protoToString.call(&#123;&#125;)                  // &#x27;[Object Object]&#x27;protoToString.call(new Error)           // &#x27;[object Error]&#x27;protoToString.call(Math)                // &#x27;[object Math]&#x27;protoToString.call(new Date)            // &#x27;[object Date]&#x27;protoToString.call(/abc/)               // &#x27;[object RegExp]&#x27;protoToString.call(new Promise(()=&gt;&#123;&#125;)) // &#x27;[object Promise]&#x27;protoToString.call(function()&#123;&#125;)        // &#x27;[object Fuction]&#x27;protoToString.call(function*()&#123;&#125;)       // &#x27;[object GeneratorFunction]&#x27;protoToString.call(async function()&#123;&#125;)  // &#x27;[object AsyncFunction]&#x27;\nObject.prototype.toString 方法可以检测出多少种类型呢？ '几乎’所有的类型。这里用几乎是因为我发现，\nprotoToString.call(new Proxy(&#123;&#125;,()=&gt;&#123;&#125;))// &#x27;[object Object]&#x27;\n和预期的 ‘[object Proxy]’ 不一致，以后找到原因了再更新。\ntype API\n既然通过 Object.prototype.toString 可以检测出几乎所有的类型，那么我们可以将其封装成一个函数: 将要检测的值传递到该函数，经过判断返回值的数据类型。\n我的设想：\n\n写一个 type 函数，它能检测各种数据类型的值。如果是基本类型，就使用 typeof；引用类型就使用 toString 方法。此外鉴于 typeof 的结果是小写，我也希望所有的结果都是小写。\n\n/** * 获取要检测的数据类型 * @param &#123;*&#125; value The Value to check * @returns &#123;string&#125; Returns the type of data */function type(value)&#123;  const protoToString = Object.prototype.toString  const isReference = typeof value === &#x27;object&#x27; || typeof value === &#x27;function&#x27;  // 调用 toString 得到的是 &#x27;[object type]&#x27; 字符串  // type 是数据的真实类型，拿到它并转为小写就是我们需要的  return isReference ? protoToString.call(value).slice(8, -1).toLowerCase() : typeof value&#125;\n封装常用的 API\nisNumber\nfunction isNumber(value)&#123;  return type(value) === &#x27;number&#x27;&#125;\nisString\nfunction isString(value)&#123;  return type(value) === &#x27;string&#x27;&#125;\nisNull\nfunction isNull(value)&#123;  // 可以直接判断是不是 null，而无须使用 type(value) 来判断  return value === null&#125;\nisUndefined\nfunction isUndefined(value)&#123;  return type(value) === &#x27;undefined&#x27;&#125;\nisBoolean\nfunction isBoolean(value)&#123;  return type(value) === &#x27;boolean&#x27;&#125;\nisSymbol\nfunction isSymbol(value)&#123;  return type(value) === &#x27;symbol&#x27;&#125;\nisObject\nfunction isObject(value)&#123;  return value !== null &amp;&amp; type(value) === &#x27;object&#x27;&#125;\nisArray\n对于数组的检测，我更推荐 ES6 的 Array.isArray API，它用来检测数组类型。目前，所有主流浏览器都已经支持该接口。\n当然，如果你想兼容老的浏览器，那就使用 Object.prototype.toString 吧。\nfunction isArray(value)&#123;  return Array.isArray(value)&#125;\nisFunction\nfunction isFunction(value)&#123;  return type(value) === &#x27;function&#x27;&#125;\nisArguments\nfunction isArguments(value)&#123;  return type(value) === &#x27;arguments&#x27;&#125;\nisArrayLike\n检测 类数组(array-like)对象，可以参考下jQuery或者lodash的源码\nfunction isArrayLike(value)&#123;  return isObject(value) &amp;&amp; !isFunction(value) &amp;&amp; isNumber(value.length)&#125;\nisPlainObject\n检测 对象字面量(纯对象)\nfunction isPlainObject(value)&#123;  const hasOwnProperty = Object.prototype.hasOwnProperty  const funcToString = Function.prototype.toString  if ( !isObject(value) )&#123;    return false  &#125;  const proto = Object.getPrototypeOf(value)  if ( proto === null )&#123;    return true  &#125;  const Ctor = hasOwnProperty.call(proto, &#x27;constructor&#x27;) &amp;&amp; proto.constructor  return typeof Ctor === &#x27;function&#x27; &amp;&amp; Ctor instanceof Ctor &amp;&amp;       funcToString.call(Ctor) === funcToString.call(Object)&#125;\n好吧，我直接抄的 lodash\n做一下验证:\nisPlainObject([])               // falseisPlainObject(new function()&#123;&#125;) // falseisPlainObject(&#123;&#125;)               // trueisPlainObject(Object.prototype) // true","categories":["FrontEnd"],"tags":["JavaScript","JavaScript专题系列"]},{"title":"使用Mock.js模拟接口数据","url":"/2022/02/17/%E4%BD%BF%E7%94%A8Mock.js%E6%A8%A1%E6%8B%9F%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE/","content":"前言\n因为公司产品说以后都会按照他的一个产品原型开发，所以我打算搞个后台管理系统的模板，类似 vue-element-admin。\n对我来说，这可以给我省下不少的功夫，让我更快的完成工作任务，然后就有更多的时间来摸鱼，逃~)\n目前，这个模板还仅仅是一个雏形。当然，我会慢慢地去完善它，让它拥有很丰富的功能。\n好了，废话就不多说了，这次要讲的主题是 Mock。\n安装\nnpm i mockjs\n更多信息请参考: 开始 &amp; 安装\n使用\nMock 的语法，可以生成什么类型的数据，请参考: Mock.js 语法规范\nconst Mock = require(&#x27;mockjs&#x27;)const data = Mock.mock(&#123;  // 生成 1-1000 之间的整数  &#x27;id|1-1000&#x27;: 1,  // 生成唯一机器码  guid: &#x27;@guid&#x27;,  // 生成长度为1-4的数组  &#x27;records|1-4&#x27;: [    &#123;      // 属性值自动加 1， 初始值为 number      &#x27;id|+1&#x27;: 1,      // bool值，true 或 false      &#x27;sex|1&#x27;: true,      // 随机id      userId: &#x27;@id&#x27;,      // 根据正则表达式规则生成手机号      mobile: /^1[3456789]\\d&#123;9&#125;$/,      // 生成长度5的字符串      &#x27;userName|5&#x27;: &#x27;&#x27;,      // 从数组中选择一个      &#x27;userFullname|1&#x27;: [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王二&#x27;],      // 当前时间      createTime: &#x27;@now()&#x27;,    &#125;  ],&#125;)console.log(data)\n// 输出:\n&#123;    &quot;id&quot;: 195,    &quot;guid&quot;: &quot;3Fd83228-54bD-c81B-f5c2-e77bAC92ceA7&quot;,    &quot;records&quot;: [        &#123;            &quot;id&quot;: 1,            &quot;sex&quot;: false,            &quot;userId&quot;: 1,            &quot;mobile&quot;: &quot;19110026512&quot;,            &quot;userName&quot;: &quot;wJmGp&quot;,            &quot;userFullname&quot;: &quot;李四&quot;,            &quot;createTime&quot;: &quot;2022-02-17 18:52:14&quot;        &#125;    ]&#125;\n使用 axios 请求模拟数据\n注意: Mock.js 会拦截 AJAX 请求，所以你直接正常请求接口就行了。\n// /mock/user.jsconst Mock = require(&#x27;mockjs&#x27;)Mock.mock(&#x27;/api/user/list&#x27;, &#x27;get&#x27;, &#123;  responseCode: 200,  total: 10,  currentPage: 1,  pageSize: 10,  &#x27;records|1-4&#x27;: [    &#123;      &#x27;id|+1&#x27;: 1,      &#x27;sex|1&#x27;: true,      userId: &#x27;@id&#x27;,      mobile: /^1[3456789]\\d&#123;9&#125;$/,      accessToken: &#x27;@guid&#x27;,      &#x27;userName|5&#x27;: &#x27;&#x27;,      &#x27;userFullname|1&#x27;: [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王二&#x27;],      createTime: &#x27;@now()&#x27;,    &#125;  ],&#125;)\n因为我使用的 Vue，所以在 main.js (入口文件)引入:\n...require(&#x27;../mock/user.js&#x27;)\n测试:\n// demo.jsaxios.get(&#x27;/api/user/list&#x27;).then(res =&gt; &#123;  console.log(res)&#125;)\n参考\nmockjs-demo\nMock\n","categories":["FrontEnd"],"tags":["JavaScript"]},{"title":"JavaScript专题之new的模拟实现","url":"/2022/02/22/JavaScript%E4%B8%93%E9%A2%98%E4%B9%8Bnew%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/","content":"一句话介绍new:\n\nnew 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。\n\n这句话似乎有点不是很好理解。在模拟 new 之前，我们先看看 new 做了什么事情。\n举个栗子:\n// 前端开发function FrontEndDeveloper(name, age) &#123;  this.name = name  this.age = age  this.skills = [&#x27;HTML&#x27;, &#x27;CSS&#x27;, &#x27;JavaScript&#x27;, &#x27;Vue&#x27;, &#x27;React&#x27;]&#125;// 我们知道，程序员一般没有女朋友，而且发量较少FrontEndDeveloper.prototype.hasGirlfriend = falseFrontEndDeveloper.prototype.isLessHair = true// 口头禅:FrontEndDeveloper.prototype.say = function()&#123;  console.log(&#x27;996是福报&#x27;, &#x27;我要做群里最卷的那个仔&#x27;)&#125;// 理想的工作:FrontEndDeveloper.prototype.dream = function()&#123;  console.log(&#x27;钱多事少离家近&#x27;)&#125;const augest = new FrontEndDeveloper(&#x27;八月&#x27;， 20)console.log(augest.name)          // 八月console.log(augest.age)           // 20console.log(augest.hasGirlfriend) // falseconsole.log(augest.say())         // 996是福报 我要做群里最卷的那个仔console.log(augest.dream())       // 钱多事少离家近console.log(augest instanceof FrontEndDeveloper) // trueconsole.log(augest.__proto === FrontEndDeveloper.prototype) // true\n从上面的栗子，我们可以看出，augest:\n\n可以访问 FrontEndDeveloper 构造函数中的属性 ( 其实是 augest 本身的属性 )\n可以访问 FrontEndDeveloper.prototype 上的属性\n是 FrontEndDeveloper 的实例\n\n注意:\n\n虽然 augest 是 FrontEndDeveloper 的实例，但是 augest 并不是继承 FrontEndDeveloper，而是 继承 FrontEndDeveloper.prototype\n\n\nJavaScript 并不像其它OOP语言，它采用的是对象继承对象的形式(原型)，而且还不是直接的继承，而是使用了一个间接量: 用构造函数创建对象\n\n实现\n接下来，让我们来模拟 new 运算符。\n当你 new 一个构造函数的时候，new 替我们做了很多事情，它的执行步骤如下:\n\n创建一个对象\n将新创建的对象的[[prototype]]特性指向构造函数的原型对象\n将新创建的对象绑定到构造函数中的 this 并传入对应的参数，调用构造函数\n如果调用构造函数的返回结果是一个对象，则返回该对象；否则返回新创建的对象\n\nfunction mockNew()&#123;  var constructFunc = arguments[0]  var args = Array.prototype.slice.call(arguments, 1)  var target = Object.create(constructFunc.prototype)  // or   // var target = new Object()  // target.__proto__ = constructFunc.prototype  var ret = constructFunc.apply(target, args)  return (typeof ret === &#x27;object&#x27; &amp;&amp; ret) || target&#125;// 验证:function Person(name, age)&#123;  this.name = name  this.age = age&#125;var xiaoming = mockNew(Person, &#x27;xiaoming&#x27;, 21)console.log(xiaoming)                               // Person &#123;name: &quot;xiaoming&quot;, age: 21&#125;console.log(xiaoming.__proto__ === Person.prototype)  // true\n参考\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new\nhttps://github.com/mqyqingfeng/Blog/issues/13\n","categories":["FrontEnd"],"tags":["JavaScript","JavaScript专题系列"]},{"title":"commitlint + husky 规范git提交信息","url":"/2022/03/06/commitlint-husky-%E8%A7%84%E8%8C%83git%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF/","content":"\n图片来自 commitlint\n前言\n偶然间看到了这篇文章 if 我是前端团队Leader，怎么制定前端协作规范?\n于是便了解到了 git 提交规范，并在工作中实践了 AngularJS提交信息规范，所以在这个周末便写了这篇文章。\n杂乱无章的现状\n来看看我和同事写过的 git 提交信息:\nfix prod envfix bugs: #2981 #2976 #2875 #2974debugupdatemerge conflictfix zentao bug\n这里只列出了一部分提交信息，其实还存在大量的像 update, debug 等让人无语的的提交信息 😂。你可以从这种提交信息中知道它干了什么吗？😭\n规范\nAngularJS的提交信息规范 在社区中享有盛名。\n当然还存在其它的规范。不过本文只介绍 AngularJS提交信息规范。\n好处\n\n提高可读性\n信息分类，重点突出。按关键字筛选，如过滤掉代码样式的提交\n快速定位重要的提交，提高效率 🚀\n容易生成CHANGELOG.md\n\n提交信息格式\n每个提交信息由 header, body和footer 组成，各自用空行隔开。\n只有 header 是必须的，body 和 footer 都是可选的。\n&lt;header&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt;\nHeader\n&lt;type&gt;(&lt;scope&gt;): &lt;short summary&gt;  │       │             │  │       │             └─⫸ Summary in present tense. Not capitalized. No period at the end.  │       │  │       └─⫸ Commit Scope: animations|bazel|benchpress|common|compiler|compiler-cli|core|  │                          elements|forms|http|language-service|localize|platform-browser|  │                          platform-browser-dynamic|platform-server|router|service-worker|  │                          upgrade|zone.js|packaging|changelog|docs-infra|migrations|ngcc|ve|  │                          devtools  │  └─⫸ Commit Type: build|ci|docs|feat|fix|perf|refactor|test\n&lt;type&gt;和 &lt;short summary&gt; 是必须的，&lt;scope&gt; 是可选的。\ntype\n必须是以下其中之一:\n\nbuild: 构建系统或外部依赖的变更\nci: CI 配置文件和脚本的变更\ndocs: 更新文档\nfeat: 新功能，通常是能够让用户觉察到的变化，小到文案或样式修改\nfix: 修复bug\nperf: 提升性能的变更\nrefactor: 重构，代码优化，但不包括修复bug以及添加新功能。比如 代码封装，变量重命名，消除魔术数字，提高代码可读性等\ntest: 单元测试相关的变更\n\n\nℹ️ AngularJS提交信息规范 中已经移除了下面这两项 type，但是 commitlint 并没有将其移除，而且我个人觉得在开发中还是需要用到的，毕竟适合的才是最好的。\n\n\nchore: 杂项，其他无法归类的变更，比如代码合并\nstyle: 代码格式调整，对逻辑无影响。比如为按照 eslint 或 prettier 修改代码格式。注意不是 UI 变更\n\nscope\n可选。用来说明本次提交影响的范围，即简要说明修改会涉及的部分。在一个项目中保持一致最好，比如页面名、模块名、或组件名。\nsummary\n简洁描述本次提交的的改动。需要遵循以下约定:\n\n以动词开头，使用第一人称现在时，比如: change，而不是 changed 或 changes\n首字母不要大写\n结尾不用句号(.)\n\nBody\n可选。是对 Header 中 short summary 的详细描述。\n\n使用第一人称现在时，比如: fix，而不是 fixed 或 fixes\n解释提交信息体的更改动机以及更改的原因\n可以将先前行为与新行为进行比较，以说明更改的影响\n\nFooter\n一般用来关闭 issue。\n如果当前commit针对某个issue，那么可以在Footer部分关闭这个issue:\nCloses #234\n也可以一次关闭多个issue:\nCloses #123, #245, #992\n\nℹ️ 关闭某个issue并非必须使用 Closes 关键字，其实还有其他的关键字可以使用，除非你要严格地遵守 Angular 提交规范。\n参考这篇文章: 通过提交信息来关闭issue\n\nRevert commits\n如果当前提交用于还原先前的提交，它应该以 revert: 开头，后跟还原提交的 header\n提交信息 body 内容应该包含:\n\nBody 部分的格式是固定的，必须是: This reverts commit ，其中的hash是被撤销 commit 的 SHA1 标识符是\n明确描述还原提交消息的原因\n\n比如(来自Vue.js):\nrevert: feat: expose all scoped slots on this.$slotsThis reverts commit 0129b0e.\n工具\n现在开发项目基本都是团队合作，所以为了保证大家都能遵循该规范，\n可以使用 commitlint + husky 配套工具来规范代码提交。\ncommitlint 是校验git提交信息的工具，husky 用于在项目中方便地添加 git hooks。\ncommitlint\n全局安装\nnpm install -g @commitlint/cli @commitlint/config-conventional\n本地安装\nnpm install @commitlint/config-conventional @commitlint/cli -D\n配置规范\necho &quot;module.exports = &#123;extends: [&#x27;@commitlint/config-conventional&#x27;]&#125;&quot; &gt; commitlint.config.js\n测试\n需要全局安装才能在命令行使用commitlint\n# 错误示例，类型后跟一个冒号和一个空格$ echo &quot;docs:添加新的文档&quot; | commitlint⧗   input: docs:添加新的文档✖   subject may not be empty [subject-empty]✖   type may not be empty [type-empty]✖   found 2 problems, 0 warnings     (Need help? -&gt; https://github.com/conventional-changelog/commitlint#what-is-commitlint )# 正确示例$ echo &quot;docs: 添加新的文档&quot; | commitlint⧗   input: docs: 添加新的文档✔   found 0 problems, 0 warnings     (Need help? -&gt; https://github.com/conventional-changelog/commitlint#what-is-commitlint )# 或者$ commitlint &quot;docs: asdf&quot;⧗   input: build(npm): 添加package.json✔   found 0 problems, 0 warnings     (Need help? -&gt; https://github.com/conventional-changelog/commitlint#what-is-commitlint )\nhusky\n安装\nnpm install husky -D\n配置\n# Activate hooks (会在项目根下生成.husky目录)npx husky install# Add hooknpx husky add .husky/commit-msg &#x27;npx --no -- commitlint --edit &quot;$1&quot;&#x27;\n编辑 package.json，添加 prepare 脚本:\n&#123;  &quot;scripts&quot;: &#123;    &quot;prepare&quot;: &quot;husky install&quot;  &#125;&#125;\n\nℹ️ 这样做的目的是，当第一次运行该项目，执行 npm i 时会自动执行 prepare 脚本从而激活 hooks。否则，hooks 没有被激活则无法通过 commitlint 来检验提交信息。\n\n测试\n# 错误提交提交$ git commit -m &quot;忽略node_modules&quot;husky &gt; commit-msg (node v10.15.3)⧗   input: 忽略node_modules✖   subject may not be empty [subject-empty]✖   type may not be empty [type-empty]✖   found 2 problems, 0 warnings     (Need help? -&gt; https://github.com/conventional-changelog/commitlint#what-is-commitlint )husky &gt; commit-msg hook failed (add --no-verify to bypass)# 正确提交$ git commit -m &quot;build(npm): 忽略node_modules&quot;husky &gt; commit-msg (node v10.15.3)⧗   input: build(npm): 忽略node_modules✔   found 0 problems, 0 warnings     (Need help? -&gt; https://github.com/conventional-changelog/commitlint#what-is-commitlint )[master 8728336] build(npm): 忽略node_modules1 file changed, 1 insertion(+)create mode 100644 .gitignore\n禁用 husky\n某一次提交想要禁用husky，可以添加参数–no-verify\ngit commit --no-verify -m &quot;your_message&quot;\n建议\n并非要完全遵守 AngularJS提交规范。这个规范肯定是最适合 AngularJS 团队的，并不一定完全适合你和你的团队。结合自身或者团队的需求，利用配套的工具，我们完全可以做出合适的选择。\n其它工具\ncommitizen\ncommit-msg-linter\n参考\nAngular-commit-message-format\nAngular提交信息规范\nGit 提交信息规范和配套工具\nAngularJS的git commit规范推广\n","categories":["FrontEnd"],"tags":["Git"]},{"title":"[已解决] 如何修复 Kernel Panic - Not Syncing: VFS: Unable to Mount Root FS on Unknown-Block(0,0)","url":"/2022/03/09/%E5%B7%B2%E8%A7%A3%E5%86%B3-%E5%A6%82%E4%BD%95%E4%BF%AE%E5%A4%8D-Kernel-Panic-Not-Syncing-VFS-Unable-to-Mount-Root-FS-on/","content":"某天早上来到公司打开电脑，结果发现并没有进入那个我熟悉的界面，而是出现了大段的错误信息，那个时候我是非常郁闷且崩溃的😭，今天的心情似乎都不怎么好了。\n虽然是第一次碰到这种问题，但是我面不改色，毫不慌张，因为我以前被 Ubuntu 折腾过好几次了😂，可以说是‘免疫’了😃。\n当然，如果问题解决不了，最坏的结果也就是重装系统而以。\n开干。\nError Message\n\nKernel Panic - Not Syncing: VFS: Unable to Mount Root FS on Unknown-Block(0,0)\nSolution\n第一步: 选择旧的内核进入系统\n重启你的电脑，然后在引导界面，选择 Advanced options for Ubuntu 菜单，你将看到一些可选的内核项，在这里我的是\n5.13.0-30-generic(也就是出问题的内核版本)，所以我们需要选择一个以前的内核版本，经过尝试发现 5.11.0-27-generic 也可以成功进入的。\n第二步: 找到根分区的文件系统\n通过使用老版本的内核成功进入系统后，打开终端，输入: sudo fdisk -l，可以看到磁盘分区的信息:\n设备            起点       末尾       扇区   大小 类型/dev/sda1       2048     780287     778240   380M EFI 系统/dev/sda2     780288  391405567  390625280 186.3G Linux 文件系统/dev/sda3  391405568  453906431   62500864  29.8G Linux swap/dev/sda4  453906432 3907028991 3453122560   1.6T Linux 文件系统\n其实我们的目的是要找到 根分区(/) 的文件系统，从上面的信息中并不能直观地得到答案，输入 df -l，输出如下:\n文件系统            1K-块     已用       可用 已用% 挂载点.../dev/sda2       191197068 19273824  162141228   11% /...\n于是我们知道根分区的文件系统是 /dev/sda2。\n第三步: 找到出问题的内核版本\n如果你不知道在你电脑没有出问题的时候的内核版本是多少，在终端输入: dpkg --list | grep linux-image, 输出如下:\nic  linux-image-5.11.0-25-generic              5.11.0-25.27~20.04.1                  amd64        Signed kernel image genericrc  linux-image-5.11.0-27-generic              5.11.0-27.29~20.04.1                  amd64        Signed kernel image genericrc  linux-image-5.11.0-34-generic              5.11.0-34.36~20.04.1                  amd64        Signed kernel image genericrc  linux-image-5.11.0-36-generic              5.11.0-36.40~20.04.1                  amd64        Signed kernel image genericrc  linux-image-5.11.0-37-generic              5.11.0-37.41~20.04.2                  amd64        Signed kernel image genericrc  linux-image-5.11.0-38-generic              5.11.0-38.42~20.04.1                  amd64        Signed kernel image genericrc  linux-image-5.11.0-40-generic              5.11.0-40.44~20.04.2                  amd64        Signed kernel image genericrc  linux-image-5.11.0-41-generic              5.11.0-41.45~20.04.1                  amd64        Signed kernel image genericrc  linux-image-5.11.0-43-generic              5.11.0-43.47~20.04.2                  amd64        Signed kernel image genericic  linux-image-5.11.0-44-generic              5.11.0-44.48~20.04.2                  amd64        Signed kernel image genericii  linux-image-5.11.0-46-generic              5.11.0-46.51~20.04.1                  amd64        Signed kernel image genericrc  linux-image-5.13.0-25-generic              5.13.0-25.26~20.04.1                  amd64        Signed kernel image genericrc  linux-image-5.13.0-27-generic              5.13.0-27.29~20.04.1                  amd64        Signed kernel image genericiF  linux-image-5.13.0-28-generic              5.13.0-28.31~20.04.1                  amd64        Signed kernel image genericiF  linux-image-5.13.0-30-generic              5.13.0-30.33~20.04.1                  amd64        Signed kernel image genericrc  linux-image-5.8.0-43-generic               5.8.0-43.49~20.04.1                   amd64        Signed kernel image genericrc  linux-image-5.8.0-63-generic               5.8.0-63.71~20.04.1                   amd64        Signed kernel image genericii  linux-image-generic-hwe-20.04              5.13.0.30.33~20.04.17                 amd64        Generic Linux kernel image\n那个最新的就是我们需要的。在这里，我的是 5.13.0-30-generic。\n最后\n通过上面的几个步骤，我们知道了:\n\n根分区(/)的文件系统是 /dev/sda2\n我们原先的内核版本是 5.13.0-30-generic (出问题的内核版本)\n\n在终端输入以下命令:\nsudo mount /dev/sda2 /mntsudo mount --bind /dev /mnt/devsudo mount --bind /dev/pts /mnt/dev/ptssudo mount --bind /proc /mnt/procsudo mount --bind /sys /mnt/syssudo chroot /mnt\n然后更新 initramfs\nupdate-initramfs -u -k 5.13.0-30-generic\nℹ️ 5.13.0-30-generic 是出问题的内核版本，用你的内核版本替换它。\n最后，更新 grub\nupdate-grub\n更新成功后，重启你的电脑，你应该可以正常的进入你的系统了。\n大功告成！\nReference\n[SOLVED] How to Fix Kernel Panic - Not Syncing: VFS: Unable to Mount Root FS on Unknown-Block(0,0)\n","categories":["Linux"],"tags":["Linux"]},{"title":"VSCode配置Git Bash","url":"/2022/03/11/VSCode%E9%85%8D%E7%BD%AEGit-Bash/","content":"最近打算学习下小程序的开发，但是操作系统是Ubuntu，压根搞不了啊。\n虽然Github上有大佬贡献了Linux版的小程序开发者工具，但是我根本不敢用，原因是不稳定，需要各种折腾，版本很旧，我感觉对我来说花大量的时间去捣鼓这些太浪费时间了，还不如去装个Windows系统。\n众所周知，小程序官方的开发者工具只有 Windows和MacOS 版本的，腾讯压根就不会去考虑Linux用户，就像QQ，微信一样，都是社区大佬在做贡献。\n没办法，所以只能装双系统了。\n这里记录下在Win10的VSCode上配置 Git Bash 的问题。\nVSCode\nVSCodeUserSetup-ia32-1.65.2\n版本: 1.65.2\n配置\n\n\n在VSCode中，File -&gt; Preferences -&gt; Settings 或者 Ctrol + ,，找到配置区域，右上角点击 Open Settings (JSON)，打开 settings.json。\n\n\n插入以下代码:\n\n\n...&quot;git.enabled&quot;: true,&quot;git.path&quot;: &quot;D:\\\\Software\\\\Git\\\\cmd\\\\git.exe&quot;,&quot;terminal.integrated.profiles.windows&quot;: &#123;  &quot;bash&quot;: &#123;        &quot;path&quot;: &quot;D:\\\\Software\\\\Git\\\\bin\\\\bash.exe&quot;,        &quot;args&quot;: []    &#125;&#125;,&quot;terminal.integrated.defaultProfile.windows&quot;: &quot;bash&quot;\n\n输入Ctrl + `，打开终端，在右上角就可以看到 bash (Deafult) 的下拉项了，点击切换到 Git Bash 终端，大功告成！\n\n\n注意: 不同版本的 VSCode 的配置很可能时不一样的\n\n参考\nhttps://zhuanlan.zhihu.com/p/467033985\n","categories":["VSCode"],"tags":["CMD"]},{"title":"Ubuntu环境下更新chrome","url":"/2022/03/13/Ubuntu%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%9B%B4%E6%96%B0chrome/","content":"我使用的操作系统是 Ubuntu 20.04，chrome 无法自动更新，需要手动更新。\n更新 Chrome\n方式一: 终端命令\n在终端输入以下命令:\n$ sudo apt-get update$ sudo apt-get --only-upgrade install google-chrome-stable\n更新完毕，Chrome 浏览器网址中输入: chrome://version，版本从原来的 97 更新到了 99。\n方式二: 重新安装.deb包更新Chrome\n下载\nwget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb\n测试发现，无论开不开代理下载速度都非常快。\n安装:\ndpkg -i ./google-chrome-stable_current_amd64.deb\n更新 VSCode\n$ sudo add-apt-repository -y &quot;deb https://packages.microsoft.com/repos/vscode stable main &quot;$ sudo apt update$ sudo apt -y install code\n参考\nHow to update Chrome in Ubuntu 20.04\nHow to upgrade Visual Studio Code editor\n","categories":["Linux"],"tags":["Chrome","VSCode"]},{"title":"在本地环境的前端项目中配置https","url":"/2022/03/19/%E5%9C%A8%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83%E7%9A%84%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%85%8D%E7%BD%AEhttps/","content":"前言\n这几天在看一个大佬的博客，看到这个标题 Local HTTPS 的时候，一个大大的问号浮现在我的脑海中，本地还能https？\n于是带着好奇跟着文章的步骤一步步来，发现果然可行，然后就觉得自己知识面又加宽了💪。\n其实很久以前我就听说过HTTPS的鼎鼎大名，知道它是HTTP协议的安全版本，但是也仅此而已，可以说对HTTPS的了解一无所知吧😢。\n于是今天在网上找了一篇文章稍微了解了一下，知道了它大概的原理，然后就觉得自己知识面又加宽了💪。\n逃~)🏃\n使用 mkcert\n因为我使用的是Windows，所以 Install for Windows，其它的操作系统找到对应方式安装即可。\n# 安装 mkcert $ choco install mkcert# 为本地环境安装 CA$ mkcert -installCreated a new local CA 💥The local CA is now installed in the system trust store! ⚡️The local CA is now installed in the Firefox trust store (requires browser restart)! 🦊# 切换到你的项目根目录$ cd /path/to/your_project_root_path# 生成证书$ mkcert w2xi.tech &#x27;*.w2xi.tech&#x27; w2xi.test localhost 127.0.0.1 ::1Created a new certificate valid for the following names 📜 - &quot;w2xi.tech&quot; - &quot;*.w2xi.tech&quot; - &quot;w2xi.test&quot; - &quot;localhost&quot; - &quot;127.0.0.1&quot; - &quot;::1&quot;Reminder: X.509 wildcards only go one level deep, so this won&#x27;t match a.b.w2xi.tech ℹ️The certificate is at &quot;./w2xi.tech+5.pem&quot; and the key at &quot;./w2xi.tech+5-key.pem&quot; ✅It will expire on 19 June 2024 🗓\n最终成功安装了 CA，并生成 cert 及 key 两个文件，文件目录如下，接下来的步骤会用到这两个文件。\n&#123;  key: &#x27;./w2xi.tech+5-key.pem&#x27;,  cert: &#x27;./w2xi.tech+5.pem&#x27;,&#125;\n在 Webpack 中配置 https\n我测试的项目是基于 vue-cli4 的，所以直接在 vue.config.js 配置即可。\nconst fs = require(&#x27;fs&#x27;)module.exports = &#123;  //...  devServer: &#123;    https: true,    key: fs.readFileSync(&#x27;./w2xi.tech+5-key.pem&#x27;),    cert: fs.readFileSync(&#x27;./w2xi.tech+5.pem&#x27;),  &#125;&#125;\n启动项目，即可运行在 https 环境中了🚀。\n最后\n阅读大佬的博客，深刻地感受到了自己的渺小。\n路还很长，但贵在坚持。\n加油，打工人。\n参考\nhttps://shanyue.tech/frontend-engineering/local-https.html\nhttps://github.com/FiloSottile/mkcert\nhttps://juejin.cn/post/6925296374628122632\nhttps://www.cnblogs.com/you-men/p/13955113.html\n","tags":["HTTPS"]},{"title":"JavaScript专题之深浅拷贝","url":"/2022/03/22/JavaScript%E4%B8%93%E9%A2%98%E4%B9%8B%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/","content":"深浅拷贝应该算是面试的高频考点之一，而且在工作中也会经常使用到。\n浅拷贝\n简单点说，浅拷贝: “如果一个对象或数组最外层元素的值是基本类型，那么拷贝的是该值，否则拷贝的是该引用。”\nJavaScript 本身就提供了一些方法或操作来浅拷贝数组或对象。\n比如 ES5 的 Object.assign()，Array.prototype.slice()，Array.prototype.concat()\nES6+ 的 Array.from() 和 … 扩展符\n\nℹ️ 建议:\n除非是为了兼容旧浏览器，否则建议使用 ES6 语法，因为现在所有的主流浏览器都支持它。\n而且现在的编码风格指南和最佳实践都推荐使用ES6，更用 Good和Bad来区分代码的好坏了。\n更重要的是，ES6 的语法更加简洁，可读性更高。\n\n如果是浅拷贝一个对象或数组，我们更多的是使用 ES6的 展开运算符 …\n测试\n浅拷贝一个对象\nconst xiaoming = &#123; name: &#x27;小明&#x27;, profile: &#123; address: &#x27;ChansSha.China&#x27; &#125; &#125;const xiaomingCopy = &#123; ...xiaoming &#125;\n浅拷贝一个数组\nconst arr = [&#123; name: &#x27;小明&#x27; &#125;, 24]const newArr = [...arr]arr[0].name = &#x27;花花&#x27;arr[1] = 30console.log(arr)    // [&#123; name: &#x27;花花&#x27; &#125;, 30]console.log(newArr) // [&#123; name: &#x27;花花&#x27; &#125;, 24]\n我们发现，如果数组的元素是基本类型，就会直接拷贝元素的值；如果数组元素是引用类型，就会拷贝其引用；如果修改引用类型属性的值，则两者都会发生变化。\n浅拷贝的实现\n… 展开符只是一个语法糖，和 Array.from(), Object.assing() 一样，只是 JavaScript 语言本身提供的便捷方法。\n接下来我们思考一下应该如何实现对数组或对象的浅拷贝。\n其实并不难，遍历对象，把对应的属性和值放到一个新的对象就行了。\n让我们开始吧～\nfunction shallowCopy(obj)&#123;  const hasOwnProperty = Object.prototype.hasOwnProperty  const isObject = function(val)&#123;    return !!(typeof val === &#x27;object&#x27; &amp;&amp; val)  &#125;  // 其实这里还可以检测的更严谨一些，比如只有obj是数组或者是对象字面量时才通过，  // 否则直接返回对应的值，或者抛出一个错误。    if ( !isObject(obj) )&#123;    return obj  &#125;  // 根据obj的类型判断是新建一个对象还是数组  const newObj = Array.isArray(obj) ? [] : &#123;&#125;  // 遍历obj，并且只有key是obj的属性时才拷贝  for ( let key in obj )&#123;    if ( hasOwnProperty.call(obj, key) )&#123;      newObj[key] = obj[key]    &#125;  &#125;  return newObj&#125;\n深拷贝\n顾名思义，深拷贝就是对一个对象的完全复制，无论它嵌套的层级有多深，新得到的对象与原来的对象彼此独立，互不影响。\n那如何深拷贝一个对象呢？其实这里有一个小技巧，不仅适用于对象还适用于数组，额，其实它们都是对象子类型，真拗口～。\nconst arr = [&#123; id: 1, name: &#x27;xiaoming&#x27; &#125;, &#123; id: 2, name: &#x27;huahua&#x27; &#125;]const newArr = JSON.parse(JSON.stringify(arr))console.log(newArr)\n我们轻而易举地深拷贝了一个数组，是不是很方便？\n但是请小心，这种方法只适用于 JSON 安全的数据。\n\nℹ️ 像 undefined，function, symbol 以及 循环引用(对象之间互相引用) 都不符合 JSON 结构标准，支持 JSON 的语言无法处理它们。\n\nJSON.stringify(…)在对象中遇到 undefined 、function 和 symbol 时会自动将其忽略，在数组中则会返回 null (以保证单元位置不变)。\n举个栗子:\nconsole.log(JSON.parse(JSON.stringify([undefined, () =&gt; &#123;&#125;, Symbol(), 1]))) // [null, null, null, 1]console.log(JSON.parse(JSON.stringify(&#123; name: undefined, say: function()&#123;&#125;, age: 24 &#125;))) // &#123; age: 24 &#125; \n深拷贝的实现\n那如何实现一个深拷贝呢？其实原理也很简单，和浅拷贝类似，只是多了一些步骤，我们在拷贝的时候判断一下属性值的类型，如果是引用类型，就递归地调用的深拷贝函数就行了。\nfunction deepCopy(obj)&#123;  const hasOwnProperty = Object.prototype.hasOwnProperty  const isObject = function(val)&#123;    return !!(typeof val === &#x27;object&#x27; &amp;&amp; val)  &#125;  // 这里这么做是出于严谨性的考虑，原因同上。  if ( !isObject(obj) )&#123;    return obj  &#125;  const newObj = Array.isArray(obj) ? [] : &#123;&#125;  for ( let key in obj )&#123;    if ( hasOwnProperty.call(obj, key) )&#123;      const curr = obj[key]      newObj[key] = isObject(curr) ? deepCopy(curr) : curr    &#125;  &#125;  return newObj&#125;\n不知道你发现了没有，我们似乎刻意忽略了函数，要知道函数也是一个对象子类型啊。\nconst arr = &#123;   name: &#x27;xiaoming&#x27;,   profile: &#123;     address: &#x27;China&#x27;   &#125;,   say: function()&#123;     console.log(&#x27;xiaoming&#x27;)   &#125;,&#125;const newArr = deepCopy(arr)console.log(arr.profile === newArr.profile) // falseconsole.log(arr.say === newArr.say)         // true\n记得在《你不知道的JavaScript(上卷)》中这样说道：\n\n我们还不确定“复制”一个函数意味着什么。有些人会通过 toString() 来序列化一个函数的源代码(但是结果取决与JavaScript的具体实现，而且不同的引擎对于不同类型的函数处理方式不完全相同)…(P109)\n\nstructuredClone()\n在新的浏览器上已经可以使用内置的API structuredClone() 深拷贝JavaScript值了，\n浏览器开始提供原生能力了，这是个令人振奋的消息。\n浏览器兼容:\n\n\n\n\n\n\n\n\n\n\n\n\n98 ✔\n94 ✔\n98 ✔\n15.4 ✔\n84 ✔\n\n\n\n是的，这个 API 只能在新的浏览器中使用，如果你要应用在实际项目中，则需要做一些兼容性处理。\n对于这个 structuredClone 解决了什么问题，有什么不足，我这里就不赘述了，可以参考下面的链接。\n参考\nhttps://github.com/mqyqingfeng/Blog/issues/33\nhttps://web.dev/structured-clone/\nhttps://developer.mozilla.org/en-US/docs/Web/API/structuredClone\n","categories":["FrontEnd"],"tags":["JavaScript","JavaScript专题系列"]},{"title":"你必须知道的几种git commit消息撤回的方式","url":"/2022/03/26/%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E5%87%A0%E7%A7%8Dgit-commit%E6%B6%88%E6%81%AF%E6%92%A4%E5%9B%9E%E7%9A%84%E6%96%B9%E5%BC%8F/","content":"完成了项目的某个功能的开发，需要提交到本地仓库:\n$ git add .$ git commit -m &#x27;feat: 完成某个功能的开发的一个简短描述&#x27;\n提交后发现，竟然有一个文件忘记保存了，咋办？\n难道再来一遍 git add .， git commit -m ‘…’ ？\n😂 😂 😂\n上面发生的事是我前几天亲身经历的，那个时候我在想: 我可以撤回刚刚提交的那个commit吗？最好撤回到执行 git add . 操作之后，或者撤回到执行 git add . 操作之前也是可行的。\n那我们该怎么做呢？可能你已经猜到了，git这个强大的工具肯定可以帮我们解决这些问题。\n现在就让我们一起来学习一下具体的操作吧～\n🚀🚀🚀\n特殊的第一次提交\n$ mkdir demo &amp;&amp; cd demo$ git init$ echo &#x27;Hello git&#x27; &gt; README.md$ git add .$ git commit -m &#x27;docs: add README.md&#x27;$ git logcommit befb44f340a4695e1adfe2605de0d271e0e0141c (HEAD -&gt; master)Author: w2xi &lt;43wangxi@gmail.com&gt;Date:   Sat Mar 26 19:11:46 2022 +0800    docs: add README.md\n如果我们想要撤回刚刚提交的commit，当执行以下操作:\n$ git reset --soft HEAD~1fatal: 有歧义的参数 &#x27;HEAD~1&#x27;：未知的版本或路径不存在于工作区中。使用 &#x27;--&#x27; 来分隔版本和路径，例如：&#x27;git &lt;命令&gt; [&lt;版本&gt;...] -- [&lt;文件&gt;...]&#x27;\n它会直接报错，原因是 git reset --soft HEAD~1 是重置当前 HEAD 指向上一个 commit，但是现在历史记录中只有一个 commit。\n\n在第一次提交之前没有任何内容，因为每个提交都是指父提交。这使得第一次提交是特殊的(孤儿提交)，因此无法引用以前的“状态”。\n\ngit update-ref -d HEAD\n这个命令会删除 HEAD 引用，但是对文件的修改并不会丢失。\n$ git update-ref -d HEAD$ git logfatal: 您的当前分支 &#x27;master&#x27; 尚无任何提交$ cat README.mdHello git\n我们通过这个命令撤销了仓库的第一次commit\nGood job 🚀\n其实还有一种方式就是直接删除 .git，只是稍后又需要 git init / git remote add origin &lt;your_repo_url&gt; 稍显麻烦。\ngit reset\n让我们删除 .git 目录，重头再来。\n$ rm -rf .git$ git init $ echo &#x27;Hello git&#x27; &gt; README.md$ git add .$ git commit -m &#x27;docs: add README.md&#x27;$ echo &#x27;test git reset action&#x27; &gt;&gt; README.md$ git add .$ git commit -m &#x27;docs: update README.md&#x27;$ git logcommit 0722863452786c1ed467656b232e788bb16de59f (HEAD -&gt; master)Author: w2xi &lt;43wangxi@gmail.com&gt;Date:   Sat Mar 26 20:34:20 2022 +0800    docs: update README.mdcommit bf3906438b9a0f9fd01c5d25c4249a14f307a634Author: w2xi &lt;43wangxi@gmail.com&gt;Date:   Sat Mar 26 20:33:53 2022 +0800    docs: add README.md\n现在git log 有两条记录了，执行以下命令:\n$ git reset --soft HEAD~1$ git logcommit bf3906438b9a0f9fd01c5d25c4249a14f307a634 (HEAD -&gt; master)Author: w2xi &lt;43wangxi@gmail.com&gt;Date:   Sat Mar 26 20:33:53 2022 +0800    docs: add README.md$ git status位于分支 master要提交的变更：  （使用 &quot;git restore --staged &lt;文件&gt;...&quot; 以取消暂存）        修改：     README.md\n可以看到，git reset --soft HEAD~1 命令撤销最近的一个commit，但是不撤销 git add .，这不正是我们需要的吗😀？\n几个常用参数\n–mixed\n这个是默认参数。\n意思是：不删除工作空间改动代码，撤销 commit，并且撤销 git add . 操作。\ngit reset --mixed HEAD^ 和 git reset HEAD^ 效果是一样的。\n–soft\n不删除工作空间改动代码，撤销 commit，不撤销  git add .\n–hard\n删除工作空间改动代码，撤销 commit，撤销 git add .\n注意完成这个操作后，就恢复到了上一次的 commit 状态。\ngit revert\n测试前的记录信息:\n$ git logcommit 151bb40521fd8d791c8ec79511140bf879c33755 (HEAD -&gt; master)Author: w2xi &lt;43wangxi@gmail.com&gt;Date:   Sat Mar 26 20:57:43 2022 +0800    docs: add README.md$ git revert HEAD删除 README.md[master 35c5602] Revert &quot;docs: add README.md&quot; 1 file changed, 2 deletions(-) delete mode 100644 README.md$ git logcommit 35c56028fa559a6afad965e74ba017e93864b7fc (HEAD -&gt; master)Author: w2xi &lt;43wangxi@gmail.com&gt;Date:   Sat Mar 26 20:59:48 2022 +0800    Revert &quot;docs: add README.md&quot;        This reverts commit 151bb40521fd8d791c8ec79511140bf879c33755.commit 151bb40521fd8d791c8ec79511140bf879c33755Author: w2xi &lt;43wangxi@gmail.com&gt;Date:   Sat Mar 26 20:57:43 2022 +0800    docs: add README.md\n它的原理是: 在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化。它不会改变过去的历史，所以是首选方式，没有任何丢失代码的风险。\n最后\n顺便说一下，如果commit注释写错了，只是想改一下注释，只需要：\n$ git commit --amend\n此时会进入默认vim 或 nano编辑器，修改注释完毕后保存就好了。\n参考\nhttps://www.cnblogs.com/lfxiao/p/9378763.html\nhttps://www.ruanyifeng.com/blog/2019/12/git-undo.html\nhttps://cloud.tencent.com/developer/ask/77445\n","tags":["Git"]}]